package vehicle

import (
	"errors"
	"fmt"
	"os"

	"github.com/HyperloopUPV-H8/h9-backend/pkg/boards"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport/packet/protection"

	"github.com/HyperloopUPV-H8/h9-backend/internal/update_factory"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/abstraction"
	blcu_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/blcu"
	connection_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/connection"
	logger_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/logger"
	message_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/message"
	order_topic "github.com/HyperloopUPV-H8/h9-backend/pkg/broker/topics/order"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/logger"
	order_logger "github.com/HyperloopUPV-H8/h9-backend/pkg/logger/order"
	"github.com/HyperloopUPV-H8/h9-backend/pkg/transport"
	"github.com/rs/zerolog"
)

// Vehicle is the main abstraction that coordinates the backend modules.
// It receives its modules and once it is ready, the vehicle manages the flow of
// information between them, converting events generated by one module to the specific
// input for another one.
type Vehicle struct {
	broker        abstraction.Broker
	boards        map[abstraction.BoardId]abstraction.Board
	transport     abstraction.Transport
	logger        abstraction.Logger
	updateFactory *update_factory.UpdateFactory
	idToBoardName map[uint16]string
	ipToBoardId   map[string]abstraction.BoardId

	trace zerolog.Logger
}

// UserPush is the method invoked by boards to signal the user has sent information to the back
func (vehicle *Vehicle) UserPush(push abstraction.BrokerPush) error {
	switch push.Topic() {
	case order_topic.SendName:
		order, ok := push.(*order_topic.Order)
		if !ok {
			fmt.Fprintf(os.Stderr, "error casting push to order: %v\n", push)
			return nil
		}

		packet, err := order.ToPacket()
		if err != nil {
			fmt.Fprintf(os.Stderr, "error converting order to packet: %v\n", err)
			return err
		}

		err = vehicle.transport.SendMessage(transport.NewPacketMessage(packet))
		if err != nil {
			fmt.Fprintf(os.Stderr, "error sending packet: %v\n", err)
			return err
		}

		err = vehicle.logger.PushRecord(&order_logger.Record{
			Packet:    packet,
			From:      "backend",
			To:        vehicle.idToBoardName[uint16(packet.Id())],
			Timestamp: packet.Timestamp(),
		})

		if err != nil && !errors.Is(err, logger.ErrLoggerNotRunning{}) {
			fmt.Fprintln(os.Stderr, "Error pushing record to logger: ", err)
		}
	case logger_topic.EnableName:
		status, ok := push.(*logger_topic.Status)
		if !ok {
			fmt.Fprintf(os.Stderr, "error casting push to logger status: %v\n", push)
			return nil
		}

		var err error
		if status.Enable() {
			err = vehicle.logger.Start()
		} else {
			err = vehicle.logger.Stop()
		}

		if err != nil {
			status.Fulfill(!status.Enable())
		} else {
			status.Fulfill(status.Enable())
		}

	case "blcu/downloadRequest":
		download := push.(*blcu_topic.DownloadRequest)
		// TODO: get BLCU id from ADJ
		if board, exists := vehicle.boards[boards.BlcuId]; exists {
			board.Notify(abstraction.BoardNotification(
				&boards.DownloadEvent{
					BoardEvent: boards.DownloadEventId,
					BoardID:    boards.BlcuId,
					Board:      download.Board,
				},
			))
		} else {
			fmt.Fprintf(os.Stderr, "BLCU board not registered\n")
		}

	case "blcu/uploadRequest":
		// Handle both UploadRequest and UploadRequestInternal
		var uploadEvent *boards.UploadEvent
		switch u := push.(type) {
		case *blcu_topic.UploadRequestInternal:
			uploadEvent = &boards.UploadEvent{
				BoardEvent: boards.UploadEventId,
				Board:      u.Board,
				Data:       u.Data,
				Length:     len(u.Data),
			}
		case *blcu_topic.UploadRequest:
			// This shouldn't happen as the handler should convert to Internal
			fmt.Fprintf(os.Stderr, "received raw UploadRequest, expected UploadRequestInternal\n")
			return nil
		default:
			fmt.Fprintf(os.Stderr, "unknown upload type: %T\n", push)
			return nil
		}

		if board, exists := vehicle.boards[boards.BlcuId]; exists {
			board.Notify(abstraction.BoardNotification(uploadEvent))
		} else {
			fmt.Fprintf(os.Stderr, "BLCU board not registered\n")
		}

	default:
		fmt.Printf("unknow topic %s\n", push.Topic())
	}

	return nil
}

func (vehicle *Vehicle) UserPull(abstraction.BrokerRequest) (abstraction.BrokerResponse, error) {
	// TODO! Implement
	return nil, nil
}

// Request is the method invoked by a board to ask for a resource from the frontend
func (vehicle *Vehicle) Request(request abstraction.BrokerRequest) (abstraction.BrokerResponse, error) {
	return vehicle.broker.Pull(request)
}

// SendMessage is the method invoked by a board to send a message
func (vehicle *Vehicle) SendMessage(msg abstraction.TransportMessage) error {
	err := vehicle.transport.SendMessage(msg)
	return err
}

// SendPush is the method invoked by a board to send a message to the frontend
func (vehicle *Vehicle) SendPush(push abstraction.BrokerPush) error {
	return vehicle.broker.Push(push)
}

// ConnectionUpdate is the method invoked by transport to signal a connection state has changed
func (vehicle *Vehicle) ConnectionUpdate(target abstraction.TransportTarget, isConnected bool) {
	vehicle.trace.Info().Str("target", string(target)).Bool("isConnected", isConnected).Msg("connection update")
	vehicle.broker.Push(connection_topic.NewConnection(string(target), isConnected))
	if isConnected {
		vehicle.updateFactory.ClearPacketsFor(target)
		vehicle.broker.Push(order_topic.NewStateClear(string(target)))
	}
}

func (vehicle *Vehicle) notifyError(name string, err error) {
	packet := protection.NewPacket(1666, protection.FaultSeverity)
	packet.Kind = protection.ErrorHandlerKind
	packet.Name = name
	packet.Timestamp = protection.NowTimestamp()
	packet.Type = protection.IntType
	packet.Data = &protection.ErrorHandler{
		Error: err.Error(),
	}
	vehicle.broker.Push(message_topic.Push(packet, 255))
}
